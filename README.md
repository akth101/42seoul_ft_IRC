# ft_irc

IRC라는 채팅 프로토콜에 따라 소켓 프로그래밍을 이용하여 소규모 채팅 서버를 구현하는 과제입니다.  

세부 구현 사항은 아래와 같습니다.  
- 최대한 공식 서버와 비슷하게 구현해야 하며 아래의 기능들은 반드시 적용되어야 한다:  
    - 이용자는 인증, 닉네임 설정, 유저네임 설정, 채널에 들어가기, reference client를 이용한 private 메시지를 주고받는 기능을 이용할 수 있어야 한다.  
    - 한 client로부터 발송된 메시지는 채널에 들어와 있는 다른 모든 client들도 볼 수 있어야 한다.  
    - operator와 일반 유저가 있어야 한다.  
    - channel operator가 아래의 명령어들을 사용할 수 있어야 한다:  
        - KICK → channel로부터 client 방출  
        - INVITE → channel로 client 초대  
        - TOPIC → channel의 topic을 바꾸거나 볼 수 있어야 함  
        - MODE → channel의 모드를 바꿀 수 있어야 함:  
            - i: Invite-only channel을 설정하거나 삭제  
            - t: channel operator에 대한 TOPIC 명령어의 제한사항을 설정하거나 삭제  
            - k: channel key(비밀번호)를 설정하거나 삭제  
            - o: operator 권한을 주고받기  
            - l: channel에 대한 user limit을 설정하거나 삭제  

---

목차
  1. 주요 기술적 이슈와 해결 과정
  2. 평가 피드백

---

1. 주요 기술적 이슈와 해결 과정  
1.1. 프로그래밍 패러다임에 따라 설계서도 달라진다  
   IRC는 크게 소켓 프로그래밍 파트와 실제 서버동작 구현 파트로 나뉩니다.  
   소켓 프로그래밍 파트는 아래와 같이 플로우차트를 작성하면서 공부와 설계를 진행했습니다.  
<img width="1106" alt="image" src="https://github.com/user-attachments/assets/ffcae738-4ba7-4534-a195-2020fbc81f12" />
  이전까지 해오던 방식인 플로우차트였기에 별 어려움 없이 진행할 수 있었으나 문제는 서버동작 구현 파트 설계를 짤 때 발생했습니다. 채팅 서버에 들어온 유저들은 다양한 행동을 합니다. operator가 되어 다른 유저를 방출하기도 하고, 메시지를 보낸다거나 다른 유저를 초대하기도 합니다. 마치 거미줄처럼 얽혀있는 각 유저의 동작을 순차적 플로우차트로 표현하기란 상당히 난해한 일이였고 설사 표현한다고 해도 제대로 눈에 들어오지 않아 설계도의 의미가 없을 것 같았습니다. 그래서 다른 설계 기법을 찾아보았고 UML이라는 설계 기법을 찾아 아래와 같이 설계를 적용하였습니다.
 <img width="1854" alt="스크린샷 2024-09-10 오후 10 18 15" src="https://github.com/user-attachments/assets/f9b84c6e-4938-46f4-826e-73c00445b3c9" />
  UML 덕분에 서버와 클라이언트, 채널, 커맨드 클래스가 각각 어떤 관계를 맺고 있고 어느 방향으로 상호작용을 주고받는지 그리고 각각 어떤 기능을 갖고 있는지 한눈에 파악할 수 있었습니다. 물론 실제 구현 과정에서 생략되고 수정된 부분들도 있지만 초기 구현 시에 길잡이 역할을 톡톡히 해주었습니다. 저는 단순히 프로그램 설계란 플로우차트를 의미한다고만 생각하고 있었는데 절차지향이냐 객체지향이냐에 따라 달라지는 설계서의 모양을 보며 프로그래밍 패러다임에 따라 알맞는 설계도도 달라진다는 점을 직접 체험할 수 있었습니다.  
  


2. 평가 피드백  
<img width="1007" alt="image" src="https://github.com/user-attachments/assets/fe3b9ec5-3283-4e66-b4ab-fb4da5347572" />
